{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "840ae1ee-d0d8-4832-aeb9-5500c58a898c",
   "metadata": {},
   "source": [
    "###Trabajo Práctico N1\n",
    "##Mi función senoidal - Análisis y procesameinto de señales\n",
    "\n",
    "El siguiente trabajo práctico se diseña un generador de señales para llevar a cabo las primeras simulaciones que hagamos.El programa define una función que genere señales senoidales y que permita parametrizar: \n",
    "La amplitud máxima de la senoidal (volts)\n",
    "Valor medio (volts)\n",
    "Frecuencia (Hz)\n",
    "Fase (radianes)\n",
    "Cantidad de muestras digitalizada por el ADC (# muestras)\n",
    "Frecuencia de muestreo del ADC."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a996f10e-ec22-4492-8f8a-5ab49e4386f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Created on Wed Mar 12 23:40:38 2025\n",
    "\n",
    "@author: iremo\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0bda7507-228f-40ea-b477-47969908c92e",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "fs = 1000 # Hz\n",
    "N = fs\n",
    "\n",
    "pasof = fs / N # Hz\n",
    "\n",
    "Ts = 1/fs #Paso de tiempo\n",
    "Tiempoint = N * Ts # Inervalo total de tiempo\n",
    "\n",
    "\n",
    "ff = 1 # Hz\n",
    "Vmax = 1\n",
    "ph =0\n",
    "nn = N\n",
    "dc = 0\n",
    "\n",
    "def mi_funcion_sen(Vmax, dc, ff, ph, nn, fs):\n",
    "    tt = np.arange(start = 0, stop = Tiempoint, step = Ts)\n",
    "    xx = Vmax * np.sin( 2 * np.pi * ff * tt ) + dc\n",
    "    return tt, xx\n",
    "\n",
    "tt, xx = mi_funcion_sen(Vmax, dc, ff, ph, nn, fs)\n",
    "plt.plot(tt, xx, label=\"1 Hz\")\n",
    "#%%\n",
    "#otras frecuencias\n",
    "ff2=500\n",
    "ff3=999\n",
    "ff4=1001\n",
    "ff5=2001\n",
    "tt, xx = mi_funcion_sen(Vmax, dc, ff2, ph, nn, fs)\n",
    "plt.plot(tt, xx, label=\"500 Hz\")\n",
    "\n",
    "tt, xx = mi_funcion_sen(Vmax, dc, ff3, ph, nn, fs)\n",
    "plt.plot(tt, xx, label=\"999 Hz\")\n",
    "\n",
    "tt, xx = mi_funcion_sen(Vmax, dc, ff4, ph, nn, fs)\n",
    "plt.plot(tt, xx, label=\"1001 Hz\")\n",
    "\n",
    "tt, xx = mi_funcion_sen(Vmax, dc, ff5, ph, nn, fs)\n",
    "plt.plot(tt, xx, label=\"2001 Hz\")\n",
    "\n",
    "\n",
    "plt.xlabel(\"Tiempo (s)\")\n",
    "plt.ylabel(\"Amplitud\")\n",
    "plt.grid()\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "64a4b4f5-13e8-44b0-81f7-a400e96cc030",
   "metadata": {},
   "source": [
    "Se concluye:\n",
    "Para una frecuencia de muestreo de 1000Hz:\n",
    "    500 Hz es la frecuencia de Nyquist= 1000/2, por lo que\n",
    "    cualquier señal con ff>500Hz no se representa correctamente.\n",
    "    Los gráficos para f={1,1001,2001} son iguales -> las señales de frecuencia:\n",
    "        f=fs+x se ven como si fueran de frecuencia f=x.\n",
    "        (Por este motivo los gráficos que corresponden a ff= 1, 1001 y 2001 Hz están superpuestos)\n",
    "    De manera análoga, las señales con frecuencia:\n",
    "        f=fs-x, se ven como una señal de f=x invertida\n",
    "        (Po este motivo, la señal de ff=999 se ve como la señal de ff=1Hz pero espejada/invertida)\n",
    "    Por último, la señal de ff=500Hz=frecuencia de Nyquist se ve plana, esto se debe a que la señal tiene solo 2 puntos por ciclo y se \"cancelan\"\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c198d1b-bc96-4996-8d55-d4cf04edbb47",
   "metadata": {},
   "source": [
    "#Analizamos otra señal - Señal Cuadrada"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "624a26f0-75e7-4d7c-bb82-0962623c7062",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Otra señal\n",
    "x_cuadrada = np.sign(xx)\n",
    "plt.plot(tt, x_cuadrada, label=\"Señal Cuadrada\")\n",
    "plt.xlabel(\"Tiempo (s)\")\n",
    "plt.ylabel(\"Amplitud\")\n",
    "plt.grid()\n",
    "plt.legend()\n",
    "plt.show"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5d6ead5a-5060-4cea-a598-ae2527197fd5",
   "metadata": {},
   "outputs": [],
   "source": [
    "La señal cuadrada usa los últimos valores en el vector xx (ff=ff5=2001 Hz)\n",
    "Debido al aliasing, la representación gráfica equivale a una señal de 1Hz."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
